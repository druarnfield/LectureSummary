Hi everyone, welcome to module three, relational model. I record these sessions again because during the lecture sessions this morning, I didn't turn on the recording session, the recording when we have the screen sharing issue. So last week, we get ourself familiarized with introductions to database. We talk about what is the use of database, what is the characteristic of all file-based system and why the database management system is developed. We also talk about the functions of database management system, including the major components and the personnel involved. There is also a history of database management system, including the advantage and disadvantage. And at the end, we talk about the three-tier architecture for database development. So today, the relational model, this term is proposed by E.F. Codd in his paper called a relational model of data for large-shared data bank. The objective of this relational model is to create a high degree of independence between the data and the application program. So when there is a changes in the internal data representations, it won't affect the higher level, which is the application program. And it's the same if there is a changes in the program itself, it shouldn't affect, it shouldn't need any other modifications for the internal data representations. It's also for dealing with the consistency and the redundancy problem. So the objective of this module, we will talk about what is the terminology used for relational model, especially for those used by database administrator or database designer, or even the user itself. We'll talk about how the tables are used to represent data, the properties and database relationship. We will learn how to identify the keys that is used in each relational model. And we will find out the meaning of entity, integrity, and differential integrity in the end. So the terminology used. I'm pretty sure all of you are very familiar with the term tables, rows, and columns. You often use this one in Excel. For the more formal terms that normally used by database administrator or the database designer, they refer table as relations, row as tuple, and column as attribute. On the other side, they also represent table as a file, row as a record, and column as a field. This is basically what relational database store each relations in the file. So for example, I have branch table. So I will store it as branch file. So each record, each row in the table, you call it as record, and each column, you call it as a field. I will try to use these formal terms and alternative one terms as much as possible so we can get used to familiar ourself in this course. So first of all, the relations. Relations is a table with columns and rows. Only applies to logical structure of database, not the physical structure. Last week when we talk about tree-tree architecture, we talk about external level, conceptual level, and the physical level. So when you define the table, relations in this time, you are referring to the, it will be used in the external and conceptual level. You will not use it in the physical level. In each of the relationship, each of the relations, you have attributes. So the attributes is a name column of the relations. And a tuple, tuple is a row of the relations. So for example, for the attribute, you have branch table, which is here is branch relations. Then you have branch number attribute, and you have address, for example, you have address attribute for the branch. And you have a staff relations. This case, we will have staff table, and we have staff number as the attribute, and a name as the attribute as well for the staff. And for the row of relations is the record of each staff. So each row represent one record, one data. So for the table here, for here, we have branch number, street, city, postcode attributes that represent as a column of the branch relations. And each of these row is called tuple. So they have a record for each row. Domain, domain is a set of allowable values for one or more attributes. So in here, go back to the table just now, the domain of branch number, it start with B, followed by three characters. That is branch number domain. The street domain consists of character, and the city also consists of character, and the postcode also consists of character. City, street, and postcode might have the same domain, but they might have different length. For example, I define street as 20 character. I define city as 10 character. I define postcode as eight character. So in the branch, you are not allowed to have other value, because that value is not belong to the branch number domain. Okay, so domain is maybe distinct for one attribute, or it can be used by more than one attribute. In this case, the character domain is used by street and city input. Okay, let me find the other table that have domain. So for here, the branch number attribute, they have the domain name called branch number. So this branch number consists of the character, which is only four size, and range between B001 and B999. So whatever other character, but maybe you want to say A, B001, you are not allowed to, because it's already stated here, this is the domain that is predefined for branch number. For the street, they have domain called street names, which is a character with 25 characters. Again, city, they're using the same domain, but they have different size, 15. Postcode, excise, sex also using the character, but only one size. They only accept value M and value F. Date of birth using the date domain, salaries using the monetarist, which is now here, they have seven digit, and you have the decimal point for the salary. Degree, degree is the number of attributes in a relations. So let's go back to this. I'll go to this page. In this branch table, branch relations, we have four degree, four attributes. So this degree, this degree is the number of attribute belong to the relations. So when you have four degree, four attributes, it's normally, they call it as degree four, or four attributes, or four tuple. So this basically means that they have four values for that report. When you have a table or relations with only one attribute, they call it unary, or degree one, or one tuple. So there is a relation with only two tables, they call binary. For three tables, they call ternary. Four tables, that's now we call it four tuple. And if you have more than four, they call it anary. So this is what normally they use. Cardinality is the number of tuples in a relations. So cardinality is depend on the, it will change, depend on the number of record being inserted or deleted. So the cardinality is this, cardinality of branch relations is one, two, three, four, five records, five cardinality. If you add one record, so it becomes six. And you remove one, it become five. So cardinality is depend on the operations that you use in database, whether insertions or deletions. So for here, the relation database is a collection of normalized relations with distinct relation name. To make it simple, relational database is a collection of normalized tables with a distinct tables name. We will talk about normalizations in later chapter. Okay. Okay. Relation schema, is using the mathematical equations. So for here, is a name relation defined by a set of attribute and domain pairs. So when I have a list of attribute here, I have A, attribute. We'll just type it in here, so it's easier for you to understand. We have, attribute, goes to, A1, A2, A3, dot dot dot, AN. This is a list of attribute. So we have attribute of the staff, for example, staff name, and first name, I mean, staff ID, first name, last name, and so on. And we have a list of domain belong to that attribute. So we have, D equals to, A1, A2, A3, and so on until D. Okay? So for staff, so for branch number just now, the domain is B, four character, consists of B001 to B008. For the street name, the domain is character, 35 blank, and so on. So how did you define a relationship? A relationship, the relation schema, is the mix of the two, the domain and attribute and domain. So the relationship here is, we have attribute one, with domain one, sorry, attribute two with the domain two, and so on until attribute N to domain N. You can also write it as relation, attribute one, sorry, attribute one, attribute two, and so on until attribute N. So this is the same meaning. Okay? So for instance here, there is a branch number B005 and the city. So this is the value. It's actually the same as the R branch number and city. So this is the syntax that used in relation schema for the table. Let's have a look at this. We use the branch already. So to define relations for, let's say I get the smaller one. Okay. Staff number. So the staff relations, staff relation, you have staff number. So what is the staff number? It's SL21. Next one is the name, John, and so on until the branch number. Branch number. B005. B005. You can also say it as relations branch number and city. So the relation will be R staff, staff number, name, until branch number. And for the value, you can have R staff equals to SL21, John, and B005. Okay. That is how it's actually being represented in the relational model. Okay. After we talk about the relation, sorry, after we talk about the relation schema, which is the table schema, now we go into the relational database schema. So this relational database schema consists of all the tables in that database, and each of the tables name, which is table schema here, must have a distinct name. So go back to here. Maybe we name this one, this database as property foreign. Okay. Property foreign database. So we have the database name called home database. Okay. In the properties database, the schema of this property database is, consists of branch schema, branch schema, sorry, yeah, branch table, or branch relations. We have staff, property foreign, and so on until the last table here. So when you have, when you try to define the schema for the database, you are using the relation name for each table in the database. Okay. So for here, the table name is core branch, staff, property foreign, and so on. So for example, here, we have a team database that have player table, team table, and game table. Inside the player table, we have the attribute, player ID, name, address, DOB, and team number. So this whole row here is a relational schema. Okay. The relational schema that we talked in the previous slides. So it's this one, relation schema. Each row is relation schema. Team is another relation schema. In other words, it's another table. Games is another relation schema. Okay. So what is the property of relations? Relations name is distinct from all other relations names in relational schema. So each table, you need to create a unique name. You shouldn't have two same table names inside the relations. Each of a cell relations contain exactly one atomic value. So here, postcode can have only one postcode. You cannot have two types of postcode inside one cell. Same as branch number, I cannot have B005 and B007 in the same cell. Each attribute has a distinct name. So for here, branch number, street, city, code, must be unique. You cannot have two names.dan yang lain untuk menentukan aspek yang berbeza dengan atribut lain nilai dan atribut semua dari domen yang sama nilai untuk nilai berbahan semua mesti berada di domen yang sama dan berbahan berbahan yang sama, yang merupakan B, 4 karakter, mulai dengan B 001, 002, 0999, sama untuk postcode, anda hanya dibenarkan 8 karakter setiap nilai adalah berbeza, tidak ada nilai yang berbeza, bermaksud tidak ada nilai yang berbeza, jadi setiap nilai mesti berada di domen yang sama, anda tidak boleh mempunyai 2 nama Xelly Linda di dalam database pelajar yang berbeza setiap dua nilai mempunyai struktur yang sama homogenus jadi struktur report pertama sama dengan report kedua dan ketiga kita tidak boleh mempunyai nilai yang mempunyai 2 postcode kita tidak boleh mempunyai nilai yang sama dengan 2 nilai atau nilai yang berbeza kita akan berbincang tentang itu nanti aturan atribut tidak bermakna jika anda membuat report berdasarkan nilai yang sama, tetapi anda memulakan dengan struktur pertama, postcode, city, dan nombor branch, dan anda memasukkan ke dalam meja sistem database tidak peduli tetapi untuk kebijaksanaan anda, anda akan membuat report dengan struktur pertama, city, dan postcode ini adalah struktur yang kita gunakan untuk mengatasi kita tidak memasukkan city dan postcode dulu untuk kemanusiaan pengguna, ini lebih baik untuk aturan 2 postcode tidak bermakna apa maksudnya? tidak ada aturan untuk bo5 dan bo7 untuk dwdd juga lebih mudah untuk pengguna melihat jika anda mempunyai 2 London di atas anda akan dapat melihat record yang telah anda pesan anda hanya perlu menampilkan record yang telah anda pesan dan anda boleh memasukkan aturan yang sama untuk ascending dan descending record yang kedua adalah b dan sebagainya, aturan tidak bermakna mari kita perkenalkan kunci perhubungan kunci perhubungan adalah aturan atau set aturan yang wujud dalam kabel untuk mempunyai tujuan untuk mengetahui record yang telah anda pesan dan juga mencipta kaitan dengan kabel lain untuk contoh ini, saya mempunyai nombor kumpulan sebagai kunci ia menunjukkan ke kabel lain kumpulan kumpulan dan kaitan antara kumpulan kumpulan dan kumpulan kumpulan dan juga kunci ini digunakan untuk mengetahui record yang telah anda pesan jika kita menggunakan B005 sebagai kunci B005 mempunyai 222 London untuk B005 dan tidak ada kata lain untuk B005 kita mempunyai berbagai jenis kunci ini adalah beberapa yang akan kita bahas kita mempunyai super key, candidate key, primary key, alternate key dan kunci ini muncul di dalam kabel saya akan tunjukkan kepada anda contohnya kunci ini muncul di dalam kabel dan alternate key adalah hubungan antara kumpulan mari saya tunjukkan kepada anda kunci alternate ini membuat hubungan ini yang diambil dari kumpulan kumpulan ini adalah kumpulan kumpulan yang terlibat dengan super key super key adalah atribut yang diidentifikasikan secara unilas dengan kumpulan kumpulan unilas bermaksud kita tidak mempunyai record yang sama lebih dari 1 record yang mempunyai nilai yang sama di dalam kabel perhatikan bahawa seluruh atribut di dalam kabel boleh menjadi super key dan anda boleh mempunyai berbagai super key kadang-kadang banyak yang berbeza saya akan tunjukkan kepada anda apa yang disebut super key dengan kumpulan kumpulan dari term pertama kita perlu mempunyai 1 atribut atau berbagai atribut yang berbeza dengan record kita boleh gunakan nombor kumpulan yang merupakan super key kerana berbeza dengan record kita boleh gunakan poscode dalam keadaan ini kerana hanya satu jalan dan anda mempunyai nombor, ia harus unik tetapi kemungkinan mempunyai jalan yang sama di London City mungkin ada di sana, mungkin London City ini mungkin mempunyai 2 jalan yang bernama 22 Dear Route atau di Bristol, mereka mempunyai 32 Month Route jadi super key yang lain kita boleh gunakan untuk mencipta jalan dan bandar sebagai kunci unik untuk memastikan tidak ada duplikat kerana anda mungkin mempunyai 22 Dear Street di Aberdeen dan 22 Dear Street di Glasgow jadi untuk mempunyai kunci unik, kita hanya perlu mencampurkan 2 atribut dan akhirnya seluruh set atribut boleh menjadi kunci unik jadi kita boleh gunakan semua atribut jalan, bandar, bandar, poscode sebagai kunci unik jadi sekarang kita mempunyai 4 kunci unik untuk tabel, nombor, poscode, bandar nombor, bandar, poscode itu adalah kunci unik, jadi anda menghidupkan sebanyak yang anda boleh untuk tabel saya ada contoh lain di sini ada tabel yang bernama Relation Call Employee mereka mempunyai atribut, ID, nama dan alamat pekerja jadi kunci unik untuk tabel ini kita ada ID pekerja, ID pekerja dan nama pekerja ID pekerja dan alamat pekerja kita ada semua itu jadi kunci unik mempunyai semua kunci selanjutnya, kita menemukan kunci kandidat jadi sebenarnya kita tidak memerlukan semua atribut untuk mengetahui rekod jadi kita tidak memerlukan semua kunci unik kita memilih satu yang minimal yang tidak boleh dikurangkan lagi untuk mengetahui rekod jadi untuk contoh sebelumnya, kita boleh memilih kunci kandidat dan nombor kita boleh gunakan poscode dan dua-dua ini terlalu banyak untuk mengetahui rekod jadi kita boleh gunakan dua-dua ini kerana ini yang paling kecil yang boleh kita dapat kunci kandidat adalah super kunci yang nombor atribut tidak boleh dikurangkan lagi jadi ini masih boleh dikurangkan ke city, ke poscode kita tidak gunakan city sebagai super kunci city tidak boleh digunakan sebagai super kunci kerana kita ada dua rekod berdua, dua London jadi tidak unik, kita tidak boleh mempunyai rekod yang unik berdasarkan kawasan, itulah sebabnya kita menggabungkan kawasan dan kawasan tidak ada subset yang sesuai untuk kandidat kunci yang mempunyai keunikan dan mereka boleh mempunyai kandidat keunikan berbeza-beza dari super kunci ini, kita dapat dua kandidat kunci berbeza-beza contohnya, mereka gunakan meja pekerjaan tadi, dari empat kunci super yang kita jelaskan sebelumnya, mereka memilih dua kandidat kunci jadi id pekerjaan adalah salah satu yang paling kecil, mereka juga memilih nama pekerja dan alamat, untuk contoh ini, kita mengambil dua pekerja dengan nama yang sama dan tinggal di alamat yang sama, jadi kita menganggapnya sebagai kunci yang unik jadi ini adalah kandidat kunci yang dikenali dari kunci super sebelumnya kandidat kunci yang seterusnya kunci utama dikandilkan untuk mengidentifikasi dua pos yang unik dalam hubungan, jadi dari kandidat kunci yang kita jumpa, kita memilih satu kunci utama, terserah kepada kita apakah kita mahu menggunakan mana sebagai kunci utama, jadi lebih mudah bagi pengarah database atau anda sebagai pencipta database untuk memahaminya jadi dari sini dari kandidat kunci kita memilih kunci utama, yang akan kita gunakan kita boleh gunakan nombor rangka, kita hanya gunakan nombor rangka, kita boleh gunakan pos kode tidak penting hanya satu kunci utama dikandilkan dalam satu hubungan sebab itu kita hanya ada satu menunjukkan kunci utama ketika mencipta hubungan, biasanya kita mengandilkan dan ia adalah atribut pertama atau beberapa atribut pertama dalam hubungan jadi biasanya dalam hubungan skima hubungan yang ditentukan adalah kata-kata kunci utama yang mempunyai nombor rangka, alamat jalan, bandar dan pos kode jadi pengarah database memahaminya jika dikatakan di sini nombor rangka dikatakan jadi itu adalah kunci utama dan biasanya apabila kita mempunyai kunci utama, kita akan menetapkan di depan atau beberapa depan, jadi apabila kita mencipta hubungan skima, kita akan tahu itu adalah kunci utama contohnya kunci utama yang ditentukan dari contoh sebelumnya jika kita memilih kunci pekerja kita boleh memilih ID pekerja atau nama pekerja dan alamat sebagai kunci utama, tapi hanya satu kita tidak boleh memilih kedua-dua kunci seterusnya, juga disebut kunci sekundari, jadi berbanding dengan kunci utama kunci utama adalah kunci yang tidak ditentukan sebagai kunci utama dan hanya satu kunci utama jadi untuk kumpulan kita, kita mempunyai dua kunci utama kunci yang tidak ditentukan sebagai kunci utama akan menjadi kunci utama kunci utama adalah kunci yang ditentukan sebagai kunci utama contohnya, jika kita gunakan ID pekerja sebagai kunci utama jadi kunci yang lain, yang merupakan nama pekerja dan alamat akan menjadi kunci utama, atau sebaliknya, jika kita memilih yang lain ID pekerja akan menjadi kunci utama sebelum kita pergi ke kunci sederhana dan komposit mari kita kembali ke meja di sebelumnya ketika saya bercakap tentang kunci yang ada di meja jadi kunci ini, kunci super, kunci kandidat, kunci utama dan kunci utama adalah di dalam satu meja jadi di sini, kita mempunyai kunci utama yang merupakan nombor prancis, kita mengidentifikasikan kunci utama yang merupakan postcode, dan kita mempunyai kunci kandidat yang merupakan nombor prancis dan postcode dan juga kunci super, yang merupakan nombor prancis jalan dan bandar, dan postcode dan jalan bandar, bandar, postcode semua ini atribut untuk kunci ada di dalam satu meja semua ini terdapat di dalam satu meja selanjutnya kunci sederhana dan kunci komposit jadi kunci sederhana jadi kunci sederhana jadi kunci sederhana adalah kunci utama yang mempunyai satu atribut jadi untuk jadwal kita kita mengidentifikasikan nombor prancis sebagai kunci utama, jadi ini adalah kunci sederhana kerana hanya mempunyai satu atribut mari kita kembali ke meja pemandangan meja pemandangan, apa itu kunci utama kita? mari kita cari tahu apa itu kunci utama kita? jadi kunci utama ini adalah nombor klien nombor properti datum kerana kita tidak boleh mempunyai hanya nombor klien sebagai kunci, kita boleh mempunyai CR56 dan CR56 dan kita tidak boleh menggunakan nombor properti sebagai kunci kerana kita mempunyai PG4 sebab dua daripada mereka tidak boleh, kita menggabungkan ke dua jadi kita mempunyai nombor klien dan nombor properti, tapi lagi kita mungkin mempunyai klien yang sama tapi berbeza jadinya jadi kita menambahkan viewDate sebagai kunci jadi tidak penting jika kita mempunyai klien yang sama tapi berbeza jadi satu daripada kunci kunci utama yang kita dapat dapatkan adalah clientNumber, viewDate, propertyNumber dan comment dalam keadaan ini, apa kunci kandidat kita kita mempunyai set atribut yang paling kecil yang kita dapat dapatkan adalah clientNumber, propertyNumber dan viewDate jadi kita mempunyai kunci kandidat kita tidak akan gunakan kunci kandidat lain kerana ia terlalu panjang jadi dari kunci kandidat ini, kita dapat mencari kunci utama kita gunakan kunci utama yang sama dan sebab kita mempunyai kunci kandidat satu kita tidak perlu gunakan kunci alternatif kita boleh gunakan kunci kandidat lain jadi dalam keadaan ini, kita mempunyai kunci kandidat yang samaIni ada 4. Tapi tidak perlu, kerana anda pereka. Terserah anda untuk menentukan yang mana yang anda mahu gunakan. Sama ada anda mahu gunakan bahagian terakhir sebagai kunci kandidat atau tidak. Saya rasa ini terlalu lama untuk saya buat sekarang, jadi saya akan menghilangkan di dalam contoh sebelumnya. Tapi tidak penting, yang paling penting adalah anda perlu mempunyai kunci utama. Yang terdiri dari 3. Oleh kerana kunci utama terdiri dari 3 atribut, ini bukan lagi kunci yang mudah. Ia menjadi kunci komposit. Kunci komposit adalah kunci utama yang membuat lebih daripada 1 atribut. Contoh lain adalah Empoler ID Simple. Yang ini adalah kunci utama yang mudah. Kalau anda gunakan kunci lain seperti Empoler Nama dan Alamat, ia menjadi kunci komposit yang tidak mudah lagi. Ada perbezaan antara kunci simple dan kunci komposit. Ia bukan hanya digunakan untuk kunci utama. Selanjutnya adalah kunci asing. Kunci asing biasanya mengandungi 2 meja. Atau anda boleh mengandungi 1 meja, tapi mengandungi 2 meja. Ia adalah atribut yang ditetapkan di 1 meja. Ia adalah meja asas. Dan ia mencincangkan kunci utama dari beberapa meja lain. Yang disebut meja asing. Meja yang kita adakan sekarang disebut meja asas. Dan meja yang mereka menyebut adalah meja asing. Meja asing dan meja asing mungkin membuat meja yang sama. Ia boleh menyebutkan kunci asing yang menyebut. Contohnya, di meja staff, saya ada nombor staff, nama fail, posisi, dan pengurus. Saya mahu ada atribut lain yang disebutkan manajer. Saya mahu menambahkan n-page, manajer adalah John White. Apabila anda mempunyai meja lain, saya hanya perlu menggunakan nombor staff John White dan menambahkan ke atribut itu. Jadi, menjadi SL21 sebagai nombor staff manajer. Itulah kunci asing yang menyebut. Ia ada di nombor staff kerana nombor John White ada di meja staff. Nombor staff. Nombor yang ada di satu baris kolom asas mesti ada di satu baris meja asing. Ini adalah meja asas kita. Nombor staff yang ada di meja asas mesti disebutkan di meja asing. Ini adalah meja staff. Meja asas adalah tempat yang ada kunci asas. Ia akan disebutkan di meja asing. Banyak roh yang ada di meja asas mungkin terpaksa dikaitkan dengan roh yang ada di meja asing. Jadi, roh-roh yang ada di meja asing B003, B003, B003 semua disebutkan dengan satu rekod di meja asing. Itulah kunci asing. Cara ia diperkenalkan adalah meja asas adalah atribut yang disebutkan dengan kunci asas. Mari kita lihat contoh ini. Kita ada kaitan kongres. Kaitan kongres adalah 2 atribut, nama kongres dan nama negeri. Kita juga ada kaitan negeri. Kaitan negeri adalah atribut nama negeri, kaitan kod negeri dan roh-negeri. Untuk kaitan negeri, nama negeri, kod negeri, roh-ID semuanya adalah kunci kandidat. Sebab mereka menentukan setiap roh. Kita boleh gunakan 1, kita tahu Alabama. Kita boleh gunakan NY, kita tahu New York. Dan kita tidak ada berkumpulan New York dalam nama negeri yang sama. Jadi, semua ini adalah kunci kandidat. Kunci kandidat, maaf. Kita boleh pilih 1 kunci kandidat ini menjadi kunci utama dan yang lain menjadi kunci alternatif. Contohnya, saya pilih nama negeri sebagai kunci utama. Kemudian, kod negeri dan roh-ID menjadi kunci alternatif. Apabila nama negeri digunakan dalam kaitan kongres sebagai kunci asas, ia menyebutkan kunci komposit dalam kaitan kongres. Jadi, kita menyebutkan California. California, ada berkumpulan California di sini. Menyebutkan satu-satunya rekod dalam kaitan kongres. Jika anda mahu, anda boleh gunakan kod negeri daripada nama negeri. Sekali lagi, ia adalah kunci asas tetapi ia akan menunjukkan kod negeri dalam kaitan kongres. Sama juga dengan roh-ID. Jadi, roh-ID untuk negeri menunjukkan kunci asas dalam kaitan kongres. Jadi, nama negeri di sini adalah kunci asas dari kaitan kongres. Jadi, ini adalah kunci asas dari kaitan kongres yang menunjukkan kunci asas dari kaitan kongres. Kita mempunyai dua jenis kunci asas. Satu daripada mereka disebut kunci artifisial. Biasanya mudah untuk kita mengetahui rekod. Contohnya, saya mempunyai kaitan kongres. Saya mempunyai Linda, Octalina, dan Linda dan Smith. Jadi, daripada mempunyai semua nama dan rekod seperti kaitan kongres dan negeri, lebih mudah, daripada menggunakan banyak atribut untuk menjadikannya menjadi satu kunci asas, lebih baik untuk mencipta atribut baru yang merupakan nombor staf untuk mengetahui kaitan kongres Linda dan Octalina. Jadi, dari contoh sebelumnya, untuk employee id, untuk tabel pekerja, jika saya tidak mempunyai employee id, saya hanya mempunyai nama pekerja dan alamat pekerja. Saya akan menghilangkan bahagian ini. Saya hanya mempunyai alamat pekerja. Jadi, bila-bila saya mahu mencari, saya mahu mencari Linda Octalina di alamat Nunda. Tetapi, saya mempunyai Linda Octalina lain di Tuwumba. Jadi, apabila saya mencari, saya perlu memastikan saya menempatkan Linda Octalina di Tuwumba untuk mengembalikan rekod. Atau saya perlu menempatkan Linda Octalina di Nunda untuk mengembalikan rekod. Tetapi, jika anda mempunyai kunci, maaf, saya tidak tahu. Jika anda mempunyai kunci artifisial, lebih mudah untuk anda mengembalikan data jika anda mempunyai kunci. Jadi, jika saya mahu mengembalikan pelajar USQ, jika saya menggunakan kunci yang berkumpul, lebih mudah untuk saya mengembalikan rekod. Bukannya menempatkan semua nama penuh, nama terakhir dan alamat. Kelebihannya, kadang-kadang kita menggunakan entiti nyata. Contohnya, anda boleh menggunakan nombor SSN atau nombor karier. Kerana ini unik dalam kehidupan kita. Kita mempunyai nombor telefon juga. Hanya satu atribut yang sangat mudah dan efisien. Kita hanya mempunyai satu atribut nombor staff, kita hanya mempunyai satu atribut nombor jabatan. Kelebihannya, kadang-kadang kerana ini tercipta secara tidak semestinya, nombor jabatan, mulai dari D001, D002, D003, dengan atribut sendiri, tidak ada makna sama sekali. Ia memerlukan jenis khas untuk penambahan, penambahan nombor seterusnya. Dan ia memerlukan ruang tambahan. Contohnya, untuk kumpulan tadi, kita mempunyai B99. Jika saya mempunyai 1000 rekod, saya perlu mencipta satu lagi yang menjadi B1000. Jadi, daripada menggunakan 4 karakter, menjadi ruang 5 karakter. Untuk alam semula jadi, seperti contoh sebelumnya, kita boleh menggabungkan atribut berlipat untuk membuatnya unik. Seperti di sini, kita gunakan nama terakhir, hari lahir dan seks. Jadi, apabila kita ingin mencari Octalina dan hari lahir dan seks saya, saya boleh menerima data. Jadi, ia sentiasa berkaitan dengan entiti sebenar. Jadi, ia sentiasa bermakna. Kerana kita tahu nama terakhir, kita tahu nama yang terakhir, kita tahu nama seks. Dan tiada ruang tambahan atau jenis yang diperlukan kerana kita menggunakan atribut yang sudah ada. Kita tidak perlu mencipta nama dan nombor seterusnya atau nombor jabatan. Kelebihannya, ia lebih kompleks kerana ia adalah kunci utama kompaun dan menggunakan lebih daripada satu atribut. Jadi, kunci asing adalah kompaun dan mungkin perlu diubah pada masa. Jadi, atributnya akan menjadi unik. Contohnya, sekarang saya ada Octalina sebagai nama terakhir saya, saya ada hari lahir saya, saya ada F untuk seks saya. Tetapi, jika ada orang lain dengan nama terakhir Octalina dengan hari lahir dan seks yang sama, maka rekod itu tidak unik lagi. Jadi, kita mungkin perlu menambahkan atribut yang lain yang disebut nama pertama. Jadi, mungkin nama pertama adalah Stephen. Nama pertama adalah Lydia. Dan nama terakhir Octalina. Walaupun mereka mempunyai nama terakhir dan seks yang sama, nama pertama membuat rekod menjadi unik. Tetapi, jika ada orang lain dengan nama terakhir dan seks yang sama, kita perlu mencipta rekod lagi. Jadi, lebih baik menggunakan kunci asing kerana nombor yang ditambahkan adalah unik. Contohnya, kita ada meja hotel. Kita letakkan di Microsoft Word. Untuk hotel, yang terdapat di bawah, kita boleh gunakannya sebagai kunci asing kerana itulah cara kita menyebutkan kunci asing. HotelTable, kunci super kita adalah hotelNumber. Kita tidak boleh menamakan kunci yang unik kerana kita mungkin mempunyai nama hotel yang sama. Tetapi kita boleh gunakan nama dan kota sebagai kunci super. Kita ada 2 kunci super, hotel dan nama dan kota. Seterusnya, kita dapatkan kunci komposit. Kunci komposit adalah kunci terkecil yang kita dapatkan. Kita boleh gunakan hotelNumber. Kita ada 1 kunci super lagi. HotelNumber, nama dan kota. Jadi, kunci komposit, kita ambil 2 kunci, nama dan kota dan hotelNumber. Dari kunci komposit, kita dapatkan kunci utama yang adalah hotelNumber. Kunci alternatif adalah hotelNumber. Itu adalah untuk hotelTable. Seterusnya, untuk bilik. Kita dapatkan kunci utama, kunci super, roomNumber. Kita tidak boleh gunakan roomNumber sebagai kunci kerana kita mungkin mempunyai bilik yang sama dari hotel yang berbeza. Jadi, kita ada bilik 111 dari hotelA, kita juga ada bilik 111 dari hotelB. Cara terbaik adalah untuk menggabungkan kedua-dua bilik untuk membuatnya unik. Jadi, kita ada bilik 111 dari hotelA. Jadi, itu unik. Kita juga ada kunci super lain. Selepas itu, kita ada kunci komposit. Kunci komposit untuk bilik ini adalah roomNumber dan hotelNumber. Kita boleh memilih satu kunci komposit. Untuk bilik ini, saya akan memilih kunci komposit ini dan saya akan gunakan kunci komposit ini sebagai kunci utama. Oleh kerana kita tidak mempunyai kunci komposit lain, mereka tidak akan mempunyai kunci utama untuk bilik ini. Untuk memudahkan, kita akan buat guest dulu. Untuk kunci super, kita ada guestNumber. Kita ada guestName dan guestNumber. Sebagai kunci super. Selepas itu, kunci komposit. Ia akan menjadi guestNumber. Kita buatnya juga, guestName dan guestName. Kunci utama untuk bilik ini adalah guestNumber. Kunci utama adalah guestName. Akhirnya, untuk tabel penyeliapan, mari kita lihat. Untuk membuat record unik, kita perlu ada hotelNumber, guestNumber, dan jadwal dari bila tetapi tetapi. Hari ini, ada pelajar yang kata, mungkin ada tetapi yang sama, dan juga ada buku untuk bilik yang berbeza. Jadi, kita perlu ada guestNumber, hotelNumber, bila untuk penyeliapan, dan roomNumber sebagai kunci utama. Sebab kita mungkin ada berbagai hotelNumber, berbagai guestNumber, berbagai jadwal yang sama, berbagai jadwal yang berbeza, dan berbagai bilik. Jadi, setiap satu daripada mereka tidak unik lagi dalam tabel penyeliapan ini. Jadi, apabila kita gabungkan semua ke satu, kita hanya ada satu record setiap satu. Sebab kita tidak akan ada guest yang sama, yang membuat record dari jadwal yang sama dan jadwal yang sama dalam bilik yang sama. Sebab itulah, semua atribut ini diperkirakan sebagai kunci utama. Untuk membuat record, kita ada hotelNumber, guestNumber, dateNum, dateTo dan roomNumber sebagai kunci utama. Jadi, kita ada kunci utama yang mudah, yang adalah hotelNumber yang berkongsi dari satu atribut, dan kita juga ada kunci utama yang berkongsi dari satu atribut. Itu adalah perbezaan antara jadwal dan kunci utama. Kita juga ada kunci asing. Jadi, hotelNumber adalah kunci asing yang berkongsi dengan perbezaan hotel atau meja hotel. Ia sama dengan guestNumber. Kunci asing adalah meja yang berkongsi dengan meja guest. RoomNumber juga berkongsi dengan roomNumber. Jadi, semua kunci utama, kita gunakan kunci asing untuk berkongsi dari meja luar. Jadi, kunci utama hotel adalah hotelNumber dan roomNumber.Sebelum kita teruskan, mari kita lihat lagi tentang Key Composite Key Composite adalah 3 key utama, Client Number, Property Number dan View Date Key Composite adalah 4N yang menunjukkan ke tabla klient Bagian terakhir adalah Relational Integrity Pertama, kita perlu memperkenalkan Null Terminologi Null adalah nilai yang belum dikenali Contohnya, kalau mark CSC 3400, nilai tersebut tidak dikenali Null adalah menghadapi data yang tidak lengkap Null tidak sama dengan 0 dan ruang 0 dan ruang adalah nilai, nilai tidak adalah nilai Null adalah tidak terkenal Data Integrity adalah data yang telah mengisi struktur seperti perangkat dan nilai yang telah ditentukan Contoh dari sebelumnya adalah Domain Constraint, untuk membuat rekod untuk perangkat kita perlu memastikan perangkat datang dengan B0001 ke B99 format dan kita perlu memastikan perangkat mempunyai postcode yang tidak lebih dari 8 karakter Itu salah satu constraint yang membuat data berguna dalam database Itu adalah sistem keurangan database yang berfungsi Contoh yang lain adalah untuk kunci utama, kerana kita perlu menentukan rekod sebagai unik dan untuk kunci utama, kita perlu menentukan kunci utama dan untuk kunci utama, kita perlu menentukan kunci utama Data Drag and Trick adalah diperlukan dalam database dengan serius dan integriti constraint dan seperti yang saya katakan sebelumnya kunci utama tidak boleh diperlukan dan postcode harus mempunyai 8 karakter dan untuk kunci utama, kita hanya boleh mempunyai 1 karakter yang berkaitan dengan nama M atau M dan itu adalah semua integriti yang perlu diperlukan dalam database dan integriti data ini diperlukan pada masa data diperlukan dalam database jadi setiap kali rekod ditempatkan, setiap kali rekod ditempatkan mereka perlu menentukan integriti supaya tidak ada data yang hilang dan kenaikan ini boleh diperlukan untuk mencipta kunci utama contohnya, jika kita mahu mencipta kunci utama kita perlu menentukan 8 karakter untuk postcode dan hanya 4 karakter untuk nombor kunci utama ada 3 jenis integriti data yang boleh diperlukan yang digunakan untuk mengekalkan database jadi kita ada integriti entiti dan integriti referensi 2 integriti ini dikawal oleh sistem pengurusan database dan integriti yang lain adalah kawalan perniagaan yang dikawal oleh aplikasi dan program jika kita lihat, integriti entiti seperti yang saya sebutkan sebelumnya, kunci utama tidak boleh dikawal jadi, kita tidak boleh mempunyai nilai yang tidak berguna untuk nombor kunci utama jika kita mencipta kunci utama, dan kita tidak menawarkan nombor kunci utama database akan mengalami peningkatan nombor kunci utama tidak boleh dikawal setiap hubungan mesti mempunyai kunci utama jadi, di tabel kunci utama, kunci utama adalah nombor kunci utama setiap hubungan mesti mempunyai kunci utama yang mempunyai 1 atau lebih kunci utama jadi, kita akan periksa dalam sistem pengurusan database apabila rekod telah dikawal integriti seterusnya adalah integriti relasional integriti relasional ini adalah ketika kunci utama terlibat jadi, kunci utama di sini di nama negeri, mesti wujud di tabel negeri jadi, kita tidak boleh mempunyai Queensland di sini tapi Queensland adalah kunci utama yang tidak ada di tabel negeri itu maksudnya, kita perlu mencari kunci utama yang ada di tabel lain jika tidak, kunci utama di sini boleh tidak ada mungkin dari La Crosse, mereka tidak ada kunci utama, jadi boleh dikawal ketika mengadakan pengurusan database jika kunci utama ini bukan kunci utama kunci utama ini bukan kunci utama, boleh dikawal tapi ketika kunci utama ini adalah kunci utama kita perlu pastikan ada nilai di dalam untuk contoh lain yang lebih mudah difahamkan ketika kita mencipta laporan, saya mahu menambahkan laporan baru tapi saya tidak tahu di mana saya akan menambahkan saya boleh menambahkannya di Puma, Sprinter jadi, saya boleh mencipta laporan, nombor pekerja saya boleh menambahkan nama, nama terakhir, posisi dan nilai tapi saya boleh menjauhkan nombor pekerja ini kerana nombor pekerja ini hanya kunci utama yang berkaitan dengan tabel lain jadi, ketika anda adalah kunci utama tapi bukan kunci utama anda dibenarkan untuk mengambilnya atau tidak jika tabel ini, untuk melihat tabel nombor pekerja, nombor kewangan dan nilai ini adalah nilai utama maka, nilai utama tidak dibenarkan untuk dibuka jadi, ketika anda mencipta laporan, anda mesti pastikan ada nilai pekerja nilai kewangan, nilai pekerja, nilai nilai nilai komen boleh dibuka tapi anda perlu ada 3 nilai untuk nilai ini jika anda tidak mempunyai salah satu, maka akan menjadi buruk jadi, itulah maksud referensi jadi, nilai ini akan diperiksa oleh sistem pengurusan database ketika anda mencipta laporan ok, keakhiran yang terakhir adalah nilai utama yang diperlukan oleh nilai pekerja dan nilai pekerja jadi, ini telah dilakukan di nilai pengurusan jadi, contohnya kita ingin mencipta tabel contohnya, ketika anda memperlukan nilai untuk mencipta form mesti lebih dari 18 tahun, maka anda boleh membeli jadi, ketika mereka meminta anda untuk mencipta laporan program aplikasi akan memeriksa jika anda mempunyai nilai yang lebih dari 18 tahun jika tidak, maka jangan mencipta laporan jadi, nilai ini telah dilakukan di nilai aplikasi inilah yang kita panggil, pengurusan perniagaan jadi, ini telah dilakukan di nilai aplikasi yang berbeza jadi, ini mungkin mahal untuk dilakukan kerana hampir setiap nilai perlu dilakukan contohnya, jika anda ingin meminta pengguna untuk mencipta laporan anda mesti pastikan bahawa mereka tidak mencipta nilai yang kurang, mesti 0 atau jika anda ingin membuat nilai 100 dan 200, tapi tidak mencipta nilai lain jadi, anda perlu memastikan nilai ini di nilai aplikasi sebelum menghantarnya ke nilai kerja anda boleh menghantarnya ke nilai kerja, jika anda ingin memasukkan nilai produk ke dalam nilai produk nilai produk lebih dari 100 dan kurang daripada 200 anda boleh lakukan secara langsung di nilai kerja anda boleh lakukan di nilai aplikasi atau menghantarnya ke dalam nilai kerja ok, itulah model kita untuk minggu depan, kita akan ada praktikal pada 10pm sila cuba download XMPP ke dalam komputer anda dan mereka yang akan datang ke lab di USQ di Springfield akan diadakan di Debian jadi XMPP akan diadakan di Debian saya akan rekod sesi ini jika anda tidak dapat datang dan waktu pembacaan adalah 11.30 pada hari Jumaat saya akan berjumpa anda di sana terima kasih